# OSLO Terraform実装・運用ガイドライン

- [OSLO Terraform実装・運用ガイドライン](#oslo-terraform実装運用ガイドライン)
    - [はじめに](#はじめに)
    - [運用方針](#運用方針)
    - [Emoji Legend(凡例)](#emoji-legend凡例)
    - [用語集](#用語集)
    - [📓 tfstate分割単位](#-tfstate分割単位)
    - [tfファイル分割単位](#tfファイル分割単位)
    - [📓 ディレクトリ構成](#-ディレクトリ構成)
    - [命名規則](#命名規則)
      - [共通](#共通)
      - [リソースタイプ](#リソースタイプ)
      - [変数](#変数)
    - [lifecycle](#lifecycle)
    - [depends\_on](#depends_on)
    - [timeouts](#timeouts)
    - [override](#override)
    - [📓 ツール類](#-ツール類)
    - [📓 テスト](#-テスト)
    - [pre-commit](#pre-commit)
    - [.editorconfig](#editorconfig)
    - [Makefile](#makefile)
    - [📓 ボイラープレートコード](#-ボイラープレートコード)
    - [共通モジュール](#共通モジュール)
    - [🔨 Terragrunt](#-terragrunt)
    - [🔨 Terraform Workspace](#-terraform-workspace)
    - [terraform import](#terraform-import)
    - [terraform state](#terraform-state)
    - [シークレット](#シークレット)
    - [コーディング規約](#コーディング規約)
      - [全般](#全般)
      - [リソース/データソース](#リソースデータソース)
      - [変数定義](#変数定義)
      - [変数の利用](#変数の利用)
      - [メタ構文](#メタ構文)
      - [式](#式)

### はじめに

- 当ドキュメントはOSLOにおけるTerraformプロジェクトの実装・運用のガイドラインをまとめたものである
- OSLO個別プロジェクトでのCodeReviewCommentsを吸い上げ、横展開していく為の中継地点も担う
- 🔨 開発環境、ツール類、CI/CDパイプライン、等についてはスターターテンプレートのREADMEを参照
- 🔨 OSLO共通モジュール、OSLO標準IaCテンプレートについてはそれぞれのリポジトリのREADMEを参照
- 🔨 大枠のIaCの利用方針はIaC標準方針書を参照

### 運用方針

- PRに要点・メモレベルのまとめを適宜残し、一定のタイミングで整理して反映する

### Emoji Legend(凡例)

- 当ドキュメントの主な引用元は[awesome-terraform](https://github.com/shuaibiyy/awesome-terraform)となっている
- 上記で行われているように、当ドキュメントでも凡例を以下のEmojiで表現する

| Emoji | 凡例 | 概要 |
| - | - | - |
| 🆖 | アンチパターン | OSLOではアンチパターンを避ける事を第一に考える |
| 👍 | ベストプラクティス | 参考文献等で推奨されている方針の紹介。あくまで参考とする |
| 📓 | OSLO | OSLO独自の方針 |
| 🔨 | TBD | 方針検討中。草案 |

### 用語集

- 主に [terraform-best-practices](https://www.terraform-best-practices.com/key-concepts)の[key-concepts](https://www.terraform-best-practices.com/key-concepts)、または[公式ドキュメント](https://developer.hashicorp.com/terraform/docs)からの妙訳となっている

| 用語 | 原文 | 概要 | e.g. |
| - | - | - | - |
| リソース | Resources | ・Terraformがサポートしている構成管理の対象のこと<br>・公式ドキュメントではインフラオブジェクトと表現されている | aws_vpc, aws_s3_bucket |
| tfstate | tfstate | ・Terraformが管理しているリソースの現在の状態を表すファイル<br>・この中身が増えれば増えるほどTerraformのプロビジョニングが完了するまでにかかる時間が増えてしまう |  |
| モジュール | Modules | Terraformが提供するコードの共通化の機能 |  |
| リソースモジュール | Resource module | ある共通する1つの目的の為に結び付きが生じるリソース群をまとめてモジュールとしたもの。モジュールの最小単位 | AWS VPC Terraform Module |
| 公式モジュール | Published Modules | Terraform Registryに登録されている、公式バッジの付いているリソースモジュールのこと | 同上 |
| 📓 共通モジュール |  | 複数プロジェクトで利用される事を想定して作られた内製のリソースモジュールのこと | 🔨 |
| インフラモジュール | Infrastructure module | ・リソースモジュールを複数組み合わせて構成されるモジュール<br>・📓 リポジトリとインフラモジュールは1対1の関係、プロジェクトとインフラモジュールは1対多の関係となる<br>・インフラモジュールは用意する環境（本番、擬似本番、検証、他）のそれぞれのルートモジュールから呼び出される | datahub-db-migration, datahub-plat |
| インフラコンポジション | Composition | インフラモジュールを組み合わせて構成されるプロジェクトのインフラのこと | datahubのインフラ |
| ルートモジュール | Root Module | ・terraform applyが実行されるディレクトリのこと<br>・📓 ルートモジュールとtfsate(状態管理ファイル)は1対1の関係となる<br>・📓 リポジトリとルートモジュールは1対多（環境の総数）の関係となる | 🔨 |
| チャイルドモジュール | Child Module | ・モジュール内で呼び出される別のモジュールのこと<br>・インラインサブモジュールと表現する場合もある | インフラモジュール内で呼び出されるリソースモジュール |
| データソース | Data source | ・読み込み専用のオペレーションを実施する<br>・モジュールから利用される |  |
| data | data Data Source | ・基本のデータソース<br>・📓 手動で作成されたリソース、またはOSLO管轄外のリソースを参照する際にだけ使う<br>・📓 上記に該当しない場合でdataを使う場合はその理由をコメントに残すようにする<br>・🆖 同一プロジェクト複数リポジトリで管理しているインフラ同士をdataで参照してしまうと暗黙的な依存関係が生まれてしまい、出自が簡単に辿れなくなる | 🔨 |
| terraform_remote_state | terraform_remote_state Data Source | ・tfstateを読み込み、outputを参照するデータソース<br>・📓 特別な理由が無い限り、tfstateを跨いだ参照はこのterraform_remote_stateに限定する | 🔨 |
| 📓 スターターテンプレート |  | ・OSLO Terraformプロジェクトスターターテンプレートリポジトリのこと<br>・詳細はスターターテンプレートのREADMEを参照 | 🔨 |
| 📓 モジュールテンプレート |  | ・OSLO Terraform共通モジュールスターターテンプレートリポジトリのこと<br>・詳細はモジュールテンプレートのREADMEを参照 | 🔨 |
| 📓 コストの低いテスト | less expensive test methods | ・リソースの作成・削除・変更の伴わないテスト群を指す<br>・PRへのコミットでCI/CDパイプラインで都度実行される想定 | tflint, "terraform validate", "terraform fmt -check" |
| モジュールインテグレーションテスト | Module integration testing | ・リソースの作成・削除・変更の伴うテスト群を指す<br>・ローカル、またはCI/CDパイプラインにて手動で実行される想定 | terratest |
| ボイラープレート | boilerplates | 📓 コピー&ペーストしたら使えるものの総称とする<br> |  |
| ボイラープレートコード | boilerplate code | 繰り返し用意が必要となるコード、及びファイル | terraform.tf, backend.tf, provider.tf, version.tf, variable.tf, data.tf |
| テンプレート | template | 📓 コピー&ペーストした後に中身を埋めていかないと使えないものの総称とする |  |
| 📓 IaCテンプレート |  | ・OSLO IaC標準テンプレートリポジトリのこと<br>・詳細はIaCテンプレートのREADMEを参照 | 🔨 |

### 📓 tfstate分割単位

- tfstateは開発チーム毎に分ける
  - その中から更に責務で分ける
    - 責務とリポジトリは1対1となる
    - その中から更に環境毎に分割する
- アプリケーションコードと1対1になるTerraformコードは同一リポジトリで管理する
- 👍 [GoogleTFベストプラクティス](https://cloud.google.com/docs/terraform/best-practices-for-terraform?hl=ja)では「承認要件と管理要件が異なる構成は、異なるソース管理リポジトリに分割する」事を設計の基本原則としている
- 👍 プロビジョニングのパフォーマンスの観点で1つのtfstateで管理するリソース数は100以下に抑えるのが良いとされている

### tfファイル分割単位

- 深い結びつきのあるリソース群(論理グループ)は、なるべく同じファイル（{論理グループ名}.tf）に配置する
- 🆖 全てのリソースに独自のファイルを割り当てる事を避ける

### 📓 ディレクトリ構成

- 基本的に一般的なTerraformプロジェクトのディレクトリ構成を踏襲していく
- スターターテンプレートをforkしてTerraformプロジェクトを構築する事でOSLOプロジェクトでのディレクトリ構成の統一を目指す
- 各階層の詳細はスターターテンプレートのREADMEを参照
- Terraformプロジェクトが以下のどちらに該当しても、基本的に同じディレクトリ構成とする
  - アプリケーションコードとの同居
  - インフラのみ

### 命名規則

#### 共通

- 個別プロジェクトの命名規則を先ず参照すること
- もしアプリケーション側に命名規則がある場合、参考にする
- 基本的には"_"を使用して単語を分ける
  - 理由が説明出来るのであれば"-"を使用しても良い
  - 例：人間の目に触れる命名であれば"-"で区切り、そうで無い場合は"_"で区切るというルールにする、など
  - 👍 命名に"_"が使えて"-"が使えない制約が少なからず存在する為、Terraform内では"_"に統一するのが望ましい

#### リソースタイプ

- 🆖 リソース名でリソースタイプを繰り返さないようにする
- 👍 リソース名は単数名詞にする
- そのリソースタイプが唯一であった場合、リソース名はmainにする
  - 🆖 mainとthisのリソース名が混在しないようにする
    - thisと名付けられているコードを参考にする場合、mainに名前を変える事を忘れないようにする
- そのリソースタイプが複数回定義される場合、それらを区別する意味のあるリソース名を付ける
  - 例：メインとサブの2つの場合：primary/secondary, 公開先に応じて分ける場合：private/public, アプリごと, 他

#### 変数

- 用途や目的が分かりやすい名前を付ける事をシンプルさより優先する
- bool値変数の場合はtrueとなる名前を入れる
  - 👍 e.g. enable_backup
- 数値の場合は用途に応じた単位を末尾に付ける
  - 👍 e.g. ram_size_gb
- list(...)、map(...)を使用する場合は命名は複数形にする
  - 👍 e.g. buckets
- 👍 名前を付けるときは可算名詞か不可算名詞かを意識する

### lifecycle

- DBなどのステートフルなリソースの場合はlifecycleのprevent_destroyを有効にする

### depends_on

- 依存するリソースがある場合はdepends_onを記載する

### timeouts

- timeoutsブロックが提供されているリソースタイプの場合、環境毎の設定を検討する
  - 検証環境である場合、短めに設定する、など

### override

- プロビジョニングの後ろ方のタイミングで値を書き換えたい場合、file overrideの使用を検討する

### 📓 ツール類

- 基本的にツール類（Terraform CLI、linter、formatter、セキュリティチェック、他）はCI/CDパイプラインでの実行を想定
- スターターテンプレートをforkしてTerraformプロジェクトを構築する事でOSLOプロジェクトでのツール類の実行方法・設定の統一を目指す
- ローカル開発環境、CI/CDパイプライン、各種ツールについての詳細はスターターテンプレートのREADMEを参照

### 📓 テスト

- 基本的にコストの低いテストは必須とし、モジュールインテグレーションテストは状況に応じて実施を検討する
- スターターテンプレートをforkしてTerraformプロジェクトを構築する事でOSLOプロジェクトでコストの低いテストの実行方法の統一を目指す
- コストの低いテストについての詳細はスターターテンプレートのREADMEを参照
- 共通モジュールは基本的にモジュールインテグレーションテストを実施する
  - 🔨 モジュールインテグレーションテストはterratestを使用する
  - 詳細はモジュールテンプレートのREADMEを参照
  - テスト対象は名前が重複しない仕組みにする
    - 👍 ランダムプロバイダを用意し、inputの有無によってランダムな命名を付けるかを分岐する、など
    - テストのリソースのクリーンアップ時に誤って関係のないリソースが削除されない仕組みにする
      - 👍 理想はテストの実行用のアカウントの用意、など
    - テストは可能な限り並行で実行させる
- リソースモジュールも状況に応じてモジュールインテグレーションテストの実施を検討する
  - 手動で動作確認する場合はセットアップに多くの工数がかかってしまう、手動での動作確認での人為ミスや確認漏れを防止したい、簡単に繰り返してテストを実行出来るようにさせたい、など

### pre-commit

- terraform用のpre-commitの使用は任意とする
- 詳細はスターターレポジトリを参照

### .editorconfig

- editorconfigの使用を必須とする
- 詳細はスターターレポジトリを参照

### Makefile

- ローカルでのコマンド実行が多くなるプロジェクトであればMakefileを追加する
  - e.g. ローカルでテストの実行を行う共通モジュール、など

### 📓 ボイラープレートコード

- 実例はスタータープロジェクト、並びにIaCテンプレートを参照
- ボイラープレートコードに変更を加える場合、先ず上記への反映を行う
- ルートモジュール：
  - main.tf
    - インフラモジュールの呼び出しを行う
  - provider.tf
    - デフォルトタグを指定する
  - version.tfを用意する
    - マイナーバージョンに固定する
    - 👍 "~>" に統一する
  - backend.tfを用意する
    - S3を使用する
      - 個別プロジェクトの環境毎に用意する
    - DyanmoDBを併用する
      - 🔨 個別プロジェクト毎に用意する
  - variables.tf
    - 環境変数からmain.tfへ渡す変数を記述する
    - デフォルト値を定義する
      - アプリケーションIDなど一意の値が対象などの場合はデフォルトを省く
      - デフォルト値は商用環境に向けた値にする
    - descriptionを記載する
  - locals.tf
    - 複数のファイルで使用されるlocalsがある場合に配置する
    - 繰り返し使われるprefix、suffixはlocalsで定義する
  - 🔨末尾が.auto.tfvarsのファイルを種別毎に用意する
    - Terraformは上記を自動で読み込んでくれる
  - outputs.tf
    - 別リポジトリのルートモジュールから参照される予定の値を公開する
- インフラモジュール：
  - data.tf
    - 利用するdataの数が多い場合に配置する
  - variables.tf
    - main.tfからインフラモジュールへ渡す変数を記述する
    - デフォルト値を定義する
      - アプリケーションIDなど一意の値が対象などの場合はデフォルトを省く
      - デフォルト値は商用環境に向けた値にする
    - descriptionを記載する
  - locals.tf
    - 複数のファイルで使用されるlocalsがある場合に配置する
    - 繰り返し使われるprefix、suffixはlocalsで定義する
- リソースモジュール：
  - data.tf
    - 利用するdataの数が多い場合に配置する
  - variables.tf
    - インフラモジュールからリソースモジュールへ渡す変数を記述する
    - デフォルト値を定義する
      - アプリケーションIDなど一意の値が対象などの場合はデフォルトを省く
      - デフォルト値は商用環境に向けた値にする
    - descriptionを記載する
  - locals.tf
    - 複数のファイルで使用されるlocalsがある場合に配置する
    - 繰り返し使われるprefix、suffixはlocalsで定義する
- 🔨 共通モジュール：
  - README.md
    - モジュールの概要と詳細な使い方を記載する
  - CODEOWNERS
    - 製作者・承認者が分かるようにする
  - main.tf
    - メインの実装を記述する
  - provider.tf
    - required_providersの指定を行う
    - 🆖 共通モジュール側でproviderの指定は行わないようにする
  - versions.tf
    - タグ付きバージョンをリリースする
    - SemVer v2.0.0に準拠するようにする
  - variables.tf
    - インフラモジュールから共通モジュールへ渡す変数を記述する
    - ユースケースのある値だけ公開する
    - ラベルを引数に含める
    - デフォルト値を定義する
      - アプリケーションIDなど一意の値が対象などの場合はデフォルトを省く
      - デフォルト値は商用環境に向けた値にする
    - descriptionを記載する
  - outputs.tf
    - 利用される可能性のある値を全て公開する
    - 🆖 variables.tfの値を直接公開するのは避ける
  - locals.tf
    - 複数のファイルで使用されるlocalsがある場合に配置する
    - 繰り返し使われるprefix、suffixはlocalsで定義する
  - examples/{利用ケース}.tf
    - 利用方法のサンプルを用意する

### 共通モジュール

- 利用側はバージョンを固定する
- 個別プロジェクト対応が必要な場合、以下のフローで開発する
  - モジュールレポジトリで個別プロジェクト向けのブランチを切る
  - 利用側はブランチを指定
  - 商用稼働実績がある場合、メインブランチへの統合と各プロジェクトへの適応を検討する

### 🔨 Terragrunt

- 基本的に方針書やガイドラインでは取り扱わない
- 個別プロジェクトで利用を検討する


### 🔨 Terraform Workspace

- 基本的に方針書やガイドラインでは取り扱わない
- 個別プロジェクトで利用を検討する

### terraform import

- 🆖 基本的に使用しなくて良いように努める
- 👍 やむを得ず使用する場合は事前にtfstateのバックアップを取る

### terraform state

- 🆖 基本的にstateを直接操作する事は避ける

### シークレット

- 🆖 シークレットをコミットする事は絶対に避ける
  - 🔨 pre-commitなどのツールを導入し、事前に阻止する施策を実施する
- Terraformのプロビジョニングに必要なシークレットはGitHub Environmentsに保持し、GitHub Actionsで参照する
- アプリケーションやサービスが参照するシークレットはSecrets Manager等の特化したサービスに保持する

### コーディング規約

#### 全般

- コメントアウトした状態をコミットする場合、必ず理由をコメントとして残す
  - 可能であれば誰がコメントアウトしたかが辿れる状態にする

#### リソース/データソース

- count, for_eachは必ず定義の最初の行に記述する
- depends_onとlifecycleがある場合はその順番で末尾に記述する

#### 変数定義

- description , type, default, validationの順番で記述する
- validationは入力が原因によって起きる障害が予測出来る場合に記述する
- 🆖 validationは無闇に記述しない
- 🆖 validationを過信しすぎない
- いくつかのtypeが選択肢となる場合、最もシンプルなものを選択する(typeは一貫性より変更容易性を重視する)
  - e.g. number, string, list
- 以下の幾つかの条件が当てはまる場合、map(map(string))を使用する
  - mapの要素が全て同じ型である場合
  - 全てstringへ変換が出来る場合
- 複数の型が許される場合はanyを使用する
- 🆖 anyは無闇に使用しない
- objectでエレメントの有無によって条件分岐したい場合、optionalを使用する

#### 変数の利用

- '{}'はmapにもobjectにもなり得るため、mapを想定している場合はtomap(...)を使用する

#### メタ構文
- 同じリソースタイプのインスタンスを複数作る場合、for_eachを使う

#### 式

- 🆖 1行に複数の三項演算を含めないようにする
- 条件によってリソースをインスタンス化をするかしないかで分岐する場合はcountメタ引数を使用する
```
variable "hoges" {
  description = "hoge一覧"
  type        = list
  default     = []
}

resource "resource_type" "main" {
  // hogesに要素が無い場合は作成しない
  count = length(var.hoges) == 0 ? 0 : 1
  ...
}
```
- 正かnullかに分岐する(optional)条件はlength関数を使用する
- 2つに分岐する条件はbool値を使用する
- 3つに分岐する条件は三項演算子を使用する
- 4つ以上に分岐する条件はローカル変数を使用する
